---
title: "Internship: first try"
output: html_notebook
author: Sophie Tascedda
date: "`r Sys.Date()`"
params:
  num_regions: "15"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(CovRegFC)
library(cowplot)
library(ggplot2)
library(reshape2)
library(magrittr)
library(stringr)
library(devtools)
library(rstan)
library(abind)
library(BatchJobs)
library(reshape2)
library(rethinking)
library(cap)
params
```

Load subject info

```{r}
subject_info = read.csv("HCP_PTN820/sample_info.csv")
subject_info = subject_info[,c(
  "Subject",
  "Age",
  "Gender",
  "Acquisition",
  "PSQI_AmtSleep", # amount of sleep in hours
  "PSQI_Score" # Pittsburgh Sleep Quality Index (PSQI) Completed
  )] 
```

```{r}
sleep_duration = rep("undefined",nrow(subject_info))
sleep_duration[subject_info$PSQI_AmtSleep <= 6] = "short"
sleep_duration[(subject_info$PSQI_AmtSleep >= 7) & (subject_info$PSQI_AmtSleep <= 9)] = "conventional"
subject_info$sleep_duration = factor(sleep_duration)
table(subject_info$sleep_duration)
str(subject_info)
```
Load timeseries

```{r}
num_regions = as.integer(params$num_regions)
num_regions
channel_names = paste0("R",1:num_regions)
path = paste0("HCP_PTN820/node_timeseries/3T_HCP820_MSMAll_d",num_regions,"_ts2")
file_names = list.files(path = path,pattern = ".txt")
file_subject_ids = strsplit(file_names,split = ".txt") %>% unlist
ts = lapply(file_subject_ids,function(Subject) {
  print(paste("reading subject:",Subject))
  full_path = paste0(path,"/",Subject,".txt")
  timeseries = read.csv(full_path,header = FALSE,sep = " ")
  timeseries$Subject = Subject
  timeseries
}) %>% do.call(rbind,.) %>% data.frame
names(ts)[1:num_regions] = channel_names
```
Create 2 groups: "short" sleepers and "conventional" sleepers
```{r}
ts_subject_info = merge(ts,subject_info,by = "Subject")
ts_short = subset(ts_subject_info,sleep_duration=="short")
ts_short$timepoint = rep(1:(nrow(ts_short)/4),4)
```
```{r}
ts_conventional = subset(ts_subject_info,sleep_duration=="conventional")
ts_conventional$timepoint = rep(1:(nrow(ts_conventional)/4),4)
```

Generate our Y and X:

Short sleepers
```{r}
short_ids=unique(ts_short$Subject)
test=split(ts_short,ts_short$Subject)
short_subj=subset(subject_info,sleep_duration=="short")
short_subj <- short_subj[short_subj$Subject %in% short_ids, ]
X_short_subj<-short_subj[order(short_subj$Subject),]
Y_short <- lapply(test, "[", TRUE, -c(17:24))
Y_short <- lapply(Y_short, "[", TRUE, -c(1))

```

Conventional sleepers
```{r}
conventional_ids=unique(ts_conventional$Subject)
test2=split(ts_conventional,ts_conventional$Subject)
conventional_subj=subset(subject_info,sleep_duration=="conventional")
conventional_subj <- conventional_subj[conventional_subj$Subject %in% conventional_ids, ]
X_conv_subj<-conventional_subj[order(conventional_subj$Subject),]
Y_conv <- lapply(test2, "[", TRUE, -c(17:24))
Y_conv <- lapply(Y_conv, "[", TRUE, -c(1))
```


Select 1 covariate (here "PSQI:Score") and convert Y and X to matrices (required by capReg)
```{r}
X_short_subset<-subset(X_short_subj, select="PSQI_Score")
X_short_subset<-cbind(inter = 1, X_short_subset)
X_short_subset<-data.matrix(X_short_subset)
Y_short<-lapply(Y_short, function(x) data.matrix(x))
```
```{r}
X_conv_subset<-subset(X_conv_subj, select="PSQI_Score")
X_conv_subset<-cbind(inter = 1, X_conv_subset)
X_conv_subset<-data.matrix(X_conv_subset)
Y_conv<-lapply(Y_conv, function(x) data.matrix(x))
```

Fit capReg

```{r}
c_short<-capReg(Y_short,X_short_subset,method="CAP")
c_conv<-capReg(Y_conv,X_conv_subset,method = "CAP")
```

```{r}

c_short$beta

c_conv$beta

```

Repeat fit of capReg, this time centering Y
```{r}
Y_c_short<- lapply(Y_short, function(x) scale(x,center = TRUE, scale = FALSE))
Y_c_conv<- lapply(Y_conv, function(x) scale(x,center = TRUE, scale = FALSE))
```
```{r}
c_short2<-capReg(Y_c_short,X_short_subset,method="CAP")
c_conv2<-capReg(Y_c_conv,X_conv_subset,method = "CAP")
```

```{r}
c_short2$beta

c_conv2$beta
```

```{r}
c_short3<-capReg(Y_c_short,X_short_subset,method="CAP-C")
c_conv3<-capReg(Y_c_conv,X_conv_subset,method = "CAP-C")
```

GETTING INVERSE MATRIX

```{r}
gamma_mat_short = c_short3$gamma%*%t(c_short3$gamma)
gamma_mat_conv = c_conv3$gamma%*%t(c_conv3$gamma)
```

```{r}
temp_s<-ginv(c_short3$gamma%*%t(c_short3$gamma))
temp_c<-ginv(c_conv3$gamma%*%t(c_conv3$gamma))
```

COVARIANCE MATRIX SUBJ_1, SLEEPERS
```{r}
a<-temp_s%*%c_short3$gamma
b<-exp(c_short3$beta[1]+X_short_subset[1,2]*c_short3$beta[2])
c<-c_short3$gamma%*%temp_s
sig_hat_s1<-a*b*c
```

Next steps:
- Ricava per ogni soggetto (sia in short che in conventional) la matrice di covarianza. Come? Sample covariance.
- Poi, make prediction per cov. matrix usando la formula qui sopra. PiÃ¹ in dettaglio, fai prediction sulla matrice di cov. per ogni soggetto usando unseen X values.

Sample covariance

```{r}
t<-Y_c_short[[1]]
```

AVERAGE COVARIANCE MATRIX PER GROUP OF SLEEPERS
```{r}
subset_tasks = function(data,factor_name,level_name) {
  data_subgroup = data[which(data[factor_name] == level_name),] %>% droplevels
  region_ids = str_detect(names(ts_subject_info),"R") %>% which
  subject_ids = table(data_subgroup$Subject) %>% names
  scov = list()
  K = length(subject_ids)
  P = length(region_ids)
  scov$YY = array(dim = c(K,P,P))
  for(i in 1:K) {
    Y = subset(data_subgroup,Subject == subject_ids[i])[,region_ids]
    Y_c = scale(Y,center = TRUE,scale = FALSE)
    scov$YY[i,,] = t(Y_c) %*% Y_c
  }
  scov$N = table(data_subgroup$Subject)
  scov
}

scov_short = subset_tasks(ts_subject_info,"sleep_duration","short")
scov_conventional = subset_tasks(ts_subject_info,"sleep_duration","conventional")
```

ricavare elementi unici di x tra short e conventional
```{r}
unique(X_short_subj$PSQI_Score)%>%sort(decreasing = FALSE)
unique(X_conv_subj$PSQI_Score)%>%sort(decreasing = FALSE)
```
```{r}
a<-temp_s%*%c_short3$gamma
b<-exp(c_short3$beta[1]+X_short_subset[1,2]*c_short3$beta[2])
c<-c_short3$gamma%*%temp_s
sig_hat_s1<-a*b*c
```


























Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
